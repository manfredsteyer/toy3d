<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Toy3D</title>
    <style>
        body {
            font-family: Arial, Helvetica, sans-serif;
        }
        canvas {
            border: 1px black solid;
        }
    </style>
    

</head>
<body>
    <h1>3D Demo</h1>


    <canvas width="300" height="300" id="canvas"></canvas>
    
    <p>
        Use <b>arrow keys</b> to rotate the object
    </p>

    <script>

        const light = normalize(toPoint3d(0, 0, 1));

        function toPoint3d(x, y, z) {
            return { x, y, z }
        }

        const displaySurface = toPoint3d(0, 0, 0.5);

        const camera = {
            x: 0, 
            y: 0, 
            z: 3,
            ox: 0,
            oy: 0,
            oz: 0
        }

        // https://de.wikipedia.org/wiki/Drehmatrix
        function rotateX(point3d, alpha) {

            const sina = Math.sin(alpha);
            const cosa = Math.cos(alpha);

            const x = point3d.x;
            const y = point3d.y * cosa - point3d.z * sina;
            const z = point3d.y * sina + point3d.z * cosa;

            return { x, y, z }; 
        }

        // https://de.wikipedia.org/wiki/Drehmatrix
        function rotateY(point3d, alpha) {

            const sina = Math.sin(alpha);
            const cosa = Math.cos(alpha);

            const x = point3d.x * cosa + point3d.z * sina;
            const y = point3d.y;
            const z = point3d.x * -sina + point3d.z * cosa; 

            return { x, y, z }; 
        }

        // https://github.com/OneLoneCoder/videos/blob/master/OneLoneCoder_olcEngine3D_Part2.cpp
        function crossProduct(point3d_1, point3d_2, point3d_3) {

            const line1 = {
                x: point3d_2.x - point3d_1.x,
                y: point3d_2.y - point3d_1.y,
                z: point3d_2.z - point3d_1.z,
            };

            const line2 = {
                x: point3d_3.x - point3d_1.x,
                y: point3d_3.y - point3d_1.y,
                z: point3d_3.z - point3d_1.z,
            };

            const result = {
                x: line1.y * line2.z - line1.z * line2.y,
			    y: line1.z * line2.x - line1.x * line2.z,
			    z: line1.x * line2.y - line1.y * line2.x,
            }

            return result;
        }

        function normalize(point3d) {
            const length = Math.sqrt(point3d.x*point3d.x + point3d.y*point3d.y + point3d.z*point3d.z);
			
            const result = {
                x: point3d.x / length,
                y: point3d.y / length,
                z: point3d.z / length
            }

            return result;
        }


        const coordsAlt = [
            toPoint3d(1, -1, -1),
            toPoint3d(1, -1, 1),
            toPoint3d(-1, -1, 1),
            toPoint3d(-1, -1, -1),
            toPoint3d(1, 1, -1),
            toPoint3d(1, 1, 1),
            toPoint3d(-1, 1, 1),
            toPoint3d(-1, 1, -1)
        ];

        const areasAlt = [
            [2,3,4],
            [8,7,6],
            [5,6,2],
            [6,7,3],
            [3,7,8],
            [1,4,8],
            [1,2,4],
            [5,8,6],
            [1,5,2],
            [2,6,3],
            [4,3,8],
            [5,1,8]
        ];
        
        const coordsOrig = [
            toPoint3d(1, -1, -1), //1
            toPoint3d(1, -1, 1), //2
            toPoint3d(-1, -1, 1), //3
            toPoint3d(-1, -1, -1), //4
            toPoint3d(1, 1, -1), //5
            toPoint3d(1, 1, 1), //6
            toPoint3d(-1, 1, 1), //7
            toPoint3d(-1, 1, -1) //8
        ];

        const areasOrig =  [ 
            [1, 2, 3, 4],
            [5, 8, 7, 6],
            [5, 8, 4, 1],
            [1, 5, 6, 2],
            [2, 6, 7, 3],
            [3, 7, 8, 4]
        ];

        const coords = coordsAlt;
        const areas = areasAlt;

        // https://en.wikipedia.org/wiki/3D_projection
        function project(point3d) {
            const x = point3d.x - camera.x;
            const y = point3d.y - camera.y;
            const z = point3d.z - camera.z;

            const ex = displaySurface.x;
            const ey = displaySurface.y;
            const ez = displaySurface.z;

            const sx = Math.sin(camera.ox);
            const sy = Math.sin(camera.oy);
            const sz = Math.sin(camera.oz);

            const cx = Math.cos(camera.ox);
            const cy = Math.cos(camera.oy);
            const cz = Math.cos(camera.oz);

            const dx = cy * (sz*y+cz*x) - sy*z;
            const dy = sx * (cy*z+sy*(sz*y+cz*x)) + cx * (cz*y-sz*x);
            let dz = cx * (cy*z+sy*(sz*y+cz*x)) - sx * (cz*y-sz*x);

            //dz = dz + 0.1;

            const bx = (ez/dz) * dx + ex;
            const by = (ez/dz) * dy + ey;

            // const bx = dx / dz;
            // const by = dy / dz;


            return { x: bx, y: by };
        }
        
        const canvas = {
            width: 150,
            height: 150,
            border: 25
        }

        function toCanvasPoint(point2d) {
            const x = Math.round(point2d.x * canvas.width + canvas.width /*+  canvas.border*/); 
            const y = Math.round(point2d.y * canvas.height + canvas.height /*+  canvas.border*/); 
            return { x, y };
        }

        const ctx = document.getElementById('canvas').getContext('2d');

        const rotation = {
            ay: 0,
            ax: 0
        }

        function calcColor(area) {
            const point1 = coords3dTransformed[area[0]-1];
            const point2 = coords3dTransformed[area[1]-1];
            const point3 = coords3dTransformed[area[2]-1];

            const cross = normalize(crossProduct(point1, point2, point3));
            const intensity = cross.x * light.x + cross.y * light.y + cross.z * light.z;

            const code = Math.floor(intensity * 255);

            // console.debug('intensity', intensity);
            const rgba =  `rgb(0, ${code/2}, ${code})`;

            return rgba;
        }

        let coords3dTransformed;

        function render() {
            
            coords3dTransformed = coords.map(coord => {
                coord = rotateY(coord, rotation.ay);
                coord = rotateX(coord, rotation.ax)
                return coord;
            }); 


            const filteredAreas = areas.filter(area => {

                const point1 = coords3dTransformed[area[0]-1];
                const point2 = coords3dTransformed[area[1]-1];
                const point3 = coords3dTransformed[area[2]-1];
                // const point3 = coords3d[area[3]-1];
                
                // coord = rotateY(coord, rotation.ay);
                // coord = rotateX(coord, rotation.ax);

                const cross = normalize(crossProduct(point1, point2, point3));

                const x = point1.x - camera.x;
                const y = point1.y - camera.y;
                const z = point1.z - camera.z;

                return (cross.x * x + cross.y * y + cross.z * z) < 0;


                //return true;
            });


            const coords2d = coords3dTransformed.map(coord => {
                const point2d = project(coord);
                return toCanvasPoint(point2d);
            });

            for (area of filteredAreas) {
                ctx.lineWidth = 1;
                ctx.strokeStyle = 'black';
                ctx.fillStyle = calcColor(area);
                ctx.beginPath();
                ctx.moveTo(coords2d[area[0]-1].x, coords2d[area[0]-1].y);
                ctx.lineTo(coords2d[area[1]-1].x, coords2d[area[1]-1].y);
                ctx.lineTo(coords2d[area[2]-1].x, coords2d[area[2]-1].y);
                //ctx.lineTo(coords2d[area[3]-1].x, coords2d[area[3]-1].y);
                ctx.closePath();
                ctx.stroke();
                ctx.fill();
            } 

            // for (coord of coords) {

            //     coord = rotateY(coord, 0)
            //     const point2d = project(coord);
            //     console.debug('point2d', point2d);
            //     const {x, y} = toCanvasPoint(point2d);
            //     // ctx.beginPath();
            //     // ctx.arc(x, y, 3, 0, Math.PI * 2);
            //     // ctx.stroke();
            // }
        }

        render();

        document.addEventListener('keydown', event => {

            switch (event.key) {
                case 'ArrowLeft':
                    rotation.ay += Math.PI / 180;
                break;
                case 'ArrowRight':
                    rotation.ay -= Math.PI / 180;
                break;
                case 'ArrowUp':
                    rotation.ax -= Math.PI / 180;
                break;
                case 'ArrowDown':
                    rotation.ax += Math.PI / 180;
                break;
                default: return
            }

            
            ctx.clearRect(0, 0, 2000, 2000);
            render();
        });


    </script>

</body>
</html>